<script src="jsonstore.js"></script>
<script src="sitepile.js"></script>
<script>
// Initialize stored values
init();

/* Site type

site : The domain (or domain pattern) of the site
status : One of 'secure', 'potential', 'blacklist'

*/

var API = {
	'site.all': function() {
		var rv = [];
		jsonStorage.each(function(site, data) {
			if (site[0] == '$') return;
			data.site = site;
			rv.push(data);
		});
		return rv;
	},
	'site.get': function(args) {
		var site = jsonStorage.get(args.site);
		if (site) {
			site.site = args.site;
		}
		return site;
	},
	'site.add': function(args) {
		console.assert(args.site[0] != '$');
		console.assert(args.status);
		if (jsonStorage.has(args.site)) return false;
		jsonStorage.set(args.site, args);
		RaiseEvent('site', 'add', args);
		return true;
	},
	'site.set': function(args) {
		console.assert(args.site[0] != '$');
		console.assert(args.status);
		var data = jsonStorage.get(args.site);
		if (!data) return false;
		var changed = false
		for (k in args) {
			if (k[0] == '$') continue;
			if (data[k] != args[k]) {
				data[k] = args[k];
				changed = true;
			}
		}
		if (changed) {
			jsonStorage.set(args.site, data);
			RaiseEvent('site', 'set', data);
		}
		return true;
	},
	/// Does either an add or a set, depending on what's needed.
	'site.makeItSo': function(args) {
		console.assert(args.site[0] != '$');
		console.assert(args.status);
		var data = jsonStorage.get(args.site);
		var added = false;
		if (!data) {
			data = {};
			added = true;
		}
		var changed = false
		for (k in args) {
			if (k[0] == '$') continue;
			if (data[k] != args[k]) {
				data[k] = args[k];
				changed = true;
			}
		}
		if (changed) {
			jsonStorage.set(args.site, data);
			if (added) {
				RaiseEvent('site', 'add', data);
			} else {
				RaiseEvent('site', 'set', data);
			}
		}
		return true;
	},
	'site.del': function(args) {
		var had = jsonStorage.has(args.site);
		jsonStorage.del(args.site);
		if (had) {
			RaiseEvent('site', 'del', {site:args.site});
		}
	},
	'site.match': function(args) {
		//FIXME: Handle wildcards (GH-13)
		return jsonStorage.get(args.site);
	},
	'setting.get': function(args) {
		return jsonStorage.get('$'+args.name);
	},
	'setting.set': function(args) {
		var sname = '$'+args.name;
		var old = jsonStorage.get(sname);
		jsonStorage.set('$'+args.name, args.value)
		if (old != args.value) {
			RaiseEvent('setting', 'set', {name:args.name, value:args.value});
			return true;
		} else {
			return false;
		}
	},
	'setting.del': function(args) {
		var sname = '$'+args.name;
		var had = jsonStorage.has(sname);
		jsonStorage.del(sname)
		if (had) {
			RaiseEvent('setting', 'del', {name:args.name});
		}
	},
	'setting.has': function(args) {
		return jsonStorage.has('$'+args.name);
	},
	'haspotential': function(args, response) {
		testUrlForHttps(args.site, function(hasit) {
			response(hasit);
		});
		return {$async: true};
	},
};

function onRequest(request, sender, sendResponse) {
	console.log("Request: ", request);
	var func = request.$name;
	if (func[0] == '$' || !API[func]) {
		sendResponse({$error: new ReferenceError(func + " is not a valid API method")});
		return;
	}
	var rv = API[func](request, sendResponse);
	if (typeof rv == 'object' && rv.$async) {
		// The function will handle calling the response when it's ready.
	} else {
		sendResponse(rv);
	}
}
chrome.extension.onRequest.addListener(onRequest);
chrome.extension.onRequestExternal.addListener(onRequest);

var events = {
	'*': [],
	'site': [],
	'site.add': [],
	'site.set': [],
	'site.del': [],
	'setting': [],
	'setting.set': [],
	'setting.del': [],
};

function onConnect(port) {
	var name = '*';
	if (port.name) {
		name = port.name;
	}
	events[name].push(port);
	port.onDisconnect.addListener(function() {
		var i = events[name].indexOf(port);
		delete events[name][i];
	});
}
chrome.extension.onConnect.addListener(onConnect);
chrome.extension.onConnectExternal.addListener(onConnect);

function localConnect(name, func) {
	events[name].push(func);
}

function RaiseEvent(obj, event, args) {
	args.$object = obj;
	args.$event = event;
	args.$name = obj+'.'+event;
	
	function callit(port, i, e) {
		if (port.postMessage) {
			port.postMessage(args);
		} else {
			port(args);
		}
	}
	events['*'].forEach(callit);
	events[args.$object].forEach(callit);
	events[args.$name].forEach(callit);
}

function UpdateAllTabs(site) {
	var qi;
	if (site && site.site) { // If it's an API event
		site = site.site;
	}
	if (typeof site == 'string') {
		qi = {url: '*://'+site+'/*'};
	} else {
		qi = {};
	}
	chrome.tabs.query(qi, function(tabs) {
		tabs.forEach(function(tab) {
			UpdateTab(tab.id, tab.url);
		});
	});
}
localConnect('*', UpdateAllTabs);

function UpdateTab(tabId, url) {
	var po = new ProtoOrigin(url);
	var enabled = API['setting.get']({name:'enabled'});
	var site = API['site.match']({site:po.o});
	
	console.groupCollapsed("UpdateTab", tabId, url);
	console.log("Enabled:", enabled);
	console.log(site);
	
	if (!site) {
		console.groupEnd();
		return;
	}
	
	// Blacklist: Show with pa_blacklist.html
	// Secure, https: Show with pa_secured.html
	// Secure, http: Show with pa_broken.html
	// Potential: Show with pa_potential.html
	// Default: hide
	// All cases: Gray if disabled
	
	 // For the future: Different states have different icons
//	var icon = 'chrome://extension-icon/'+chrome.i18n.getMessage('@@extension_id')+'/16/2';
	var icon = 'lock';
	const q = '?site='+po.o+'&tabid='+tabId;
	if (site.status == 'blacklist') {
		console.log("Blacklist tab", po);
		chrome.pageAction.setPopup({tabId: tabId, popup: 'pa_blacklisted.html'+q});
		chrome.pageAction.setTitle({tabId: tabId, title: "Blacklisted"});
		chrome.pageAction.show(tabId);
		icon = 'blacklist';
	} else if (site.status == 'secure' && po.isSecure()) {
		console.log("Secured tab", po);
		chrome.pageAction.setPopup({tabId: tabId, popup: 'pa_secured.html'+q});
		chrome.pageAction.setTitle({tabId: tabId, title: "Secured"});
		chrome.pageAction.show(tabId);
		icon = 'secure';
	} else if (site.status == 'secure' && !po.isSecure()) {
		console.log("Broken tab", po);
		chrome.pageAction.setPopup({tabId: tabId, popup: 'pa_broken.html'+q});
		chrome.pageAction.setTitle({tabId: tabId, title: "Security Broken"});
		chrome.pageAction.show(tabId);
	} else if (site.status == 'potential') {
		console.log("Potential tab", po);
		chrome.pageAction.setPopup({tabId: tabId, popup: 'pa_potential.html'+q});
		chrome.pageAction.setTitle({tabId: tabId, title: "Potential"});
		chrome.pageAction.show(tabId);
		icon = 'potential';
	} else {
		chrome.pageAction.hide(tabId);
	}
	if (!enabled) {
		icon = 'gray';
	}
	chrome.pageAction.setIcon({tabId: tabId, path: chrome.extension.getURL(icon+'-128.png')});
	console.groupEnd();
}

chrome.tabs.onUpdated.addListener(function(tabId, info, tab) {
	if (info.url || info.status == "loading") {
		UpdateTab(tabId, tab.url);
	}
});

function doPotentialSite(po) {
	testUrlForHttps(po.o, function(hasHttps) {
		if (hasHttps) {
			console.log("Potential site: "+po.o);
			API['site.add']({site:po.o, status:'potential'});
		}
	});
}

var requests = {};

function onBeforeRequest(request) {
	if (!request) return {}; // on handlerBehaviorChanged() 
	
	var enabled = API['setting.get']({name:'enabled'});
	if (!enabled) return {};
	const rId = request.requestId;
	console.group("Request:", rId, request.url);
	console.log(request);
	if (!requests[rId]) {
		requests[rId] = {};
	} else if (requests[rId][request.url]) {
		console.log("Loop detected");
		console.groupEnd();
		return {};
	}
	requests[rId][request.url] = true;
	
	var po = new ProtoOrigin(request.url);
	if (!po.hasSecure()) {
		console.log("No secure version:", po.p);
		console.groupEnd();
		return {};
	}
	
	var site = API['site.match']({site:po.o});
	
	if (!site) {
		console.log("No site found");
		if (request.tabId != -1) {
			chrome.tabs.get(request.tabId, function(tab) {
				console.log("Incognito:", tab.incognito);
				console.groupEnd();
				if (!tab.incognito) {
					doPotentialSite(po);
				}
			});
		} else {
			console.log("Not a tabbed request");
			console.groupEnd();
			window.setTimeout(function() {
				doPotentialSite(po);
			}, 0);
		}
	} else if (po.hasSecure()) {
		if (site.status == 'secure') {
			var surl = po.makeSecure();
			console.log("Secure:", surl);
			if (requests[rId][surl]) {
				console.log("Loop detected");
				console.groupEnd();
				return {};
			}
			requests[rId][surl] = true;
			console.log("Redirecting "+request.url+" to "+surl);
			console.groupEnd();
			return {redirectUrl: surl}
		} else if (site.status == 'blacklist') {
			console.log("Blacklist "+request.url);
			console.groupEnd();
		} else {
			console.log("Status:", site.status);
			console.groupEnd();
		}
	}
	return {};
}
chrome.webRequest.onBeforeRequest.addListener(onBeforeRequest, {urls: ['<all_urls>'], /*types: ['main_frame']*/}, ["blocking"]);

function onBeforeRedirect(details) {
	if (!details) return; // on handlerBehaviorChanged() 
	if (requests[details.requestId]) {
		requests[details.requestId][details.url] = true;
		requests[details.requestId][details.redirectUrl] = true;
	}
}
chrome.webRequest.onBeforeRedirect.addListener(onBeforeRedirect, {urls: ['<all_urls>']});

function onCompleted(details) {
	if (!details) return; // on handlerBehaviorChanged() 
	delete requests[details.requestId];
}
chrome.webRequest.onCompleted.addListener(onBeforeRedirect, {urls: ['<all_urls>']});

/// Call this whenever our data changes
function redirectChanged() {
	chrome.webRequest.handlerBehaviorChanged(onBeforeRequest);
}
localConnect('*', redirectChanged);

// Remove this after 3-28-2012
function migrate() {
	jsonStorage.set('$enabled', jsonStorage.get('is-disabled'));
	jsonStorage.get('potential-sites').forEach(function(site) {
		jsonStorage.set(site, {site: site, status: 'potential'});
	});
	jsonStorage.get('sites').forEach(function(site) {
		jsonStorage.set(site, {site: site, status: 'secure'});
	});
	// Not migrating blacklist because we largely don't need it, and it's likely to cause problems
	jsonStorage.del('is-disabled');
	jsonStorage.del('enable-page-action');
	jsonStorage.del('potential-sites');
	jsonStorage.del('sites');
	jsonStorage.del('do-not-redirect');
}

function init() {
	if (jsonStorage.has('sites')) {
		migrate();
	}
	
	jsonStorage.setDefault('$enabled', true);
	
	UpdateAllTabs();
}

var urlCache = {};
//FIXME: Detect when a duplicate request comes in before the first finishes.
function testUrlForHttps(url, callback) {
	if (urlCache[url] != null) {
		callback(urlCache[url]);
		return;
	}
	var xhr = new XMLHttpRequest();
	xhr.open('HEAD', 'https://' + url, true);
	
	//FIXME: Detect redirects
	xhr.onreadystatechange = function(data) {
		
		if (xhr.readyState == 4) {
			
			if (xhr.status == 200) {
				urlCache[url] = true;
				callback(true);
			}
			else {
				urlCache[url] = false;
				callback(false);
			}
		}
	}

	xhr.send();
}

</script>
